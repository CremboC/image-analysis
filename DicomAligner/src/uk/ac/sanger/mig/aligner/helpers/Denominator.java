/*
 * Copyright (c) 2014-2015 Genome Research Ltd.
 * 
 * Author: Mouse Informatics Group <team110g@sanger.ac.uk>
 * This file is part of Aligner.
 * 
 * Aligner is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option ) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package uk.ac.sanger.mig.aligner.helpers;

import net.imglib2.Cursor;
import net.imglib2.meta.ImgPlus;
import net.imglib2.type.logic.BitType;

/**
 * Calculate the denominator
 * 
 * @author pi1
 */
public class Denominator {

	private final int[] x;
	private final int[] y;
	private final ImgPlus<BitType> im;

	private double denom = -0;
	private double a = 0, b = 0, c = 0;

	/**
	 * A helper class to calculate the denominator of an image.
	 * 
	 * @param x
	 *            x array generated by {@link MatrixHelper.generateX}
	 * @param y
	 *            y array generated by {@link MatrixHelper.generateY}
	 * @param im
	 *            an image of type BitType
	 */
	public Denominator(int[] x, int[] y, ImgPlus<BitType> im) {
		this.x = x;
		this.y = y;
		this.im = im;

		denom();
	}

	/**
	 * a component of the denominator: sum(sum(double(im).*x.^2))
	 * 
	 * @return -0 if denom 0, meaning probably wasn't calculate yet
	 */
	public double a() {
		if (denom == 0)
			return -0;

		return a;
	}

	/**
	 * b component of the denominator: sum(sum(double(im).*x.*y))*2
	 * 
	 * @return -0 if denom 0, meaning probably wasn't calculate yet
	 */
	public double b() {
		if (denom == 0)
			return -0;

		return b;
	}

	/**
	 * c component of the denominator: sum(sum(double(im).*y.^2))
	 * 
	 * @return -0 if denom 0, meaning probably wasn't calculate yet
	 */
	public double c() {
		if (denom == 0)
			return -0;

		return c;
	}

	/**
	 * Finds the denominator using a, b and c components: b^2 + (a - c)^2
	 * 
	 * @return
	 */
	public double denom() {
		if (denom != -0)
			return denom;

		// cursor over input image
		final Cursor<BitType> inCursor = im.localizingCursor();

		// iterate over pixels of in input image
		try {
			int i = 0;
			while (inCursor.hasNext()) {
				inCursor.fwd();

				double val = inCursor.get().getRealDouble();

				int xi = x[i], yi = y[i];

				a += Math.pow((val * xi), 2);
				b += val * xi * yi;
				c += Math.pow((val * yi), 2);

				i++;
				// because an image might have multiple dimensions, it may throw
				// an out-of-bounds exception, this if makes sure it only
				// iterates over the the image once
				if (i == im.dimension(0) * im.dimension(1))
					break;
			}
		} catch (Exception e) {
			// if by some miracle the if doesn't catch some edges cases, print
			// out the issue as "Execution failed" is not a way to present
			// errors
			System.out.println(e.getClass() + ": " + e.getMessage() + " at "
					+ this.getClass());
		}

		b *= 2;

		return (denom = Math.pow(b, 2) + Math.pow((a - c), 2));
	}
}
